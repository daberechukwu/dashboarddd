{"ast":null,"code":"import { useMemo as e, memo as r, useCallback as o, Fragment as t, useRef as i, useEffect as n } from \"react\";\nimport { useTheme as a, guessQuantizeColorScale as u, quantizeColorScalePropType as l, useDimensions as c, SvgWrapper as d, withContainer as s, ResponsiveWrapper as f, getRelativeCursor as h, bindDefs as p } from \"@nivo/core\";\nimport { BasicTooltip as g, useTooltip as v } from \"@nivo/tooltip\";\nimport m from \"prop-types\";\nimport { useInheritedColor as C, inheritedColorPropType as b } from \"@nivo/colors\";\nimport y from \"lodash/get\";\nimport R from \"lodash/isFunction\";\nimport { format as j } from \"d3-format\";\nimport { geoAzimuthalEqualArea as q, geoAzimuthalEquidistant as T, geoGnomonic as M, geoOrthographic as W, geoStereographic as w, geoEqualEarth as k, geoEquirectangular as F, geoMercator as O, geoTransverseMercator as L, geoNaturalEarth1 as E, geoPath as S, geoGraticule as G, geoContains as x } from \"d3-geo\";\nimport { useQuantizeColorScaleLegendData as B, BoxLegendSvg as P, renderLegendToCanvas as N } from \"@nivo/legends\";\nimport { jsx as H } from \"react/jsx-runtime\";\nfunction I() {\n  return I = Object.assign || function (e) {\n    for (var r = 1; r < arguments.length; r++) {\n      var o = arguments[r];\n      for (var t in o) Object.prototype.hasOwnProperty.call(o, t) && (e[t] = o[t]);\n    }\n    return e;\n  }, I.apply(this, arguments);\n}\nvar D = {\n    azimuthalEqualArea: q,\n    azimuthalEquidistant: T,\n    gnomonic: M,\n    orthographic: W,\n    stereographic: w,\n    equalEarth: k,\n    equirectangular: F,\n    mercator: O,\n    transverseMercator: L,\n    naturalEarth1: E\n  },\n  z = function (r) {\n    var o = r.width,\n      t = r.height,\n      i = r.projectionType,\n      n = r.projectionScale,\n      u = r.projectionTranslation,\n      l = r.projectionRotation,\n      c = r.fillColor,\n      d = r.borderWidth,\n      s = r.borderColor,\n      f = e(function () {\n        return D[i]().scale(n).translate([o * u[0], t * u[1]]).rotate(l);\n      }, [o, t, i, n, u[0], u[1], l[0], l[1], l[2]]),\n      h = e(function () {\n        return S(f);\n      }, [f]),\n      p = e(function () {\n        return G();\n      }),\n      g = a(),\n      v = e(function () {\n        return \"function\" == typeof d ? d : function () {\n          return d;\n        };\n      }, [d]),\n      m = C(s, g),\n      b = e(function () {\n        return \"function\" == typeof c ? c : function () {\n          return c;\n        };\n      }, [c]);\n    return {\n      projection: f,\n      path: h,\n      graticule: p,\n      getBorderWidth: v,\n      getBorderColor: m,\n      getFillColor: b\n    };\n  },\n  K = function (r) {\n    var o = r.features,\n      t = r.data,\n      i = r.match,\n      n = r.label,\n      a = r.value,\n      l = r.valueFormat,\n      c = r.colors,\n      d = r.unknownColor,\n      s = r.domain,\n      f = e(function () {\n        return R(i) ? i : function (e, r) {\n          var o = y(e, i),\n            t = y(r, i);\n          return o && o === t;\n        };\n      }, [i]),\n      h = e(function () {\n        return R(n) ? n : function (e) {\n          return y(e, n);\n        };\n      }, [n]),\n      p = e(function () {\n        return R(a) ? a : function (e) {\n          return y(e, a);\n        };\n      }, [a]),\n      g = e(function () {\n        return void 0 === l ? function (e) {\n          return e;\n        } : R(l) ? l : j(l);\n      }, [l]),\n      v = e(function () {\n        return u(c).domain(s);\n      }, [c, s]),\n      m = e(function () {\n        return function (e) {\n          return void 0 === e.value ? d : v(e.value);\n        };\n      }, [v, d]),\n      C = e(function () {\n        return o.map(function (e) {\n          var r = t.find(function (r) {\n              return f(e, r);\n            }),\n            o = p(r);\n          if (r) {\n            var i = I({}, e, {\n              data: r,\n              value: o,\n              formattedValue: g(o)\n            });\n            return i.color = m(i), i.label = h(i), i;\n          }\n          return e;\n        });\n      }, [o, t, f, p, g, m]),\n      b = B({\n        scale: v,\n        valueFormat: g\n      });\n    return {\n      colorScale: v,\n      getFillColor: m,\n      boundFeatures: C,\n      valueFormatter: g,\n      legendData: b\n    };\n  },\n  V = r(function (e) {\n    var r = e.feature;\n    return void 0 === r.data ? null : H(g, {\n      id: r.label,\n      color: r.color,\n      enableChip: !0,\n      value: r.formattedValue\n    });\n  });\nV.propTypes = {\n  feature: m.object.isRequired\n}, V.displayName = \"ChoroplethTooltip\";\nvar A = {\n    features: m.arrayOf(m.shape({\n      id: m.string.isRequired,\n      type: m.oneOf([\"Feature\"]).isRequired,\n      properties: m.object,\n      geometry: m.object.isRequired\n    })).isRequired,\n    projectionType: m.oneOf(Object.keys(D)).isRequired,\n    projectionScale: m.number.isRequired,\n    projectionTranslation: m.arrayOf(m.number).isRequired,\n    projectionRotation: m.arrayOf(m.number).isRequired,\n    fillColor: m.oneOfType([m.string, m.func]).isRequired,\n    borderWidth: m.oneOfType([m.number, m.func]).isRequired,\n    borderColor: b.isRequired,\n    enableGraticule: m.bool.isRequired,\n    graticuleLineWidth: m.number.isRequired,\n    graticuleLineColor: m.string.isRequired,\n    isInteractive: m.bool.isRequired,\n    onMouseEnter: m.func.isRequired,\n    onMouseMove: m.func.isRequired,\n    onMouseLeave: m.func.isRequired,\n    onClick: m.func.isRequired,\n    tooltip: m.any,\n    layers: m.arrayOf(m.oneOfType([m.oneOf([\"graticule\", \"features\"]), m.func])).isRequired\n  },\n  J = I({}, A, {\n    role: m.string.isRequired\n  }),\n  Q = I({\n    pixelRatio: m.number.isRequired\n  }, A),\n  U = {\n    data: m.arrayOf(m.object).isRequired,\n    match: m.oneOfType([m.string, m.func]).isRequired,\n    label: m.oneOfType([m.string, m.func]).isRequired,\n    value: m.oneOfType([m.string, m.func]).isRequired,\n    valueFormat: m.oneOfType([m.string, m.func]),\n    colors: l.isRequired,\n    domain: m.arrayOf(m.number).isRequired,\n    unknownColor: m.string.isRequired,\n    layers: m.arrayOf(m.oneOfType([m.oneOf([\"graticule\", \"features\", \"legends\"]), m.func])).isRequired\n  },\n  X = I({}, J, U, {\n    role: m.string.isRequired\n  }),\n  Y = I({}, Q, U),\n  Z = {\n    projectionType: \"mercator\",\n    projectionScale: 100,\n    projectionTranslation: [.5, .5],\n    projectionRotation: [0, 0, 0],\n    enableGraticule: !1,\n    graticuleLineWidth: .5,\n    graticuleLineColor: \"#999999\",\n    fillColor: \"#dddddd\",\n    borderWidth: 0,\n    borderColor: \"#000000\",\n    isInteractive: !0,\n    onMouseEnter: function () {},\n    onMouseLeave: function () {},\n    onMouseMove: function () {},\n    onClick: function () {},\n    layers: [\"graticule\", \"features\"],\n    legends: [],\n    fill: [],\n    defs: []\n  },\n  $ = I({}, Z, {\n    role: \"img\"\n  }),\n  _ = I({}, Z, {\n    pixelRatio: \"undefined\" != typeof window && window.devicePixelRatio || 1\n  }),\n  ee = {\n    match: \"id\",\n    label: \"id\",\n    value: \"value\",\n    colors: \"PuBuGn\",\n    unknownColor: \"#999\",\n    tooltip: V,\n    layers: [\"graticule\", \"features\", \"legends\"]\n  },\n  re = I({}, $, ee, {\n    role: \"img\"\n  }),\n  oe = I({}, _, ee),\n  te = r(function (e) {\n    var r = e.path,\n      o = e.graticule,\n      t = e.lineWidth,\n      i = e.lineColor;\n    return H(\"path\", {\n      fill: \"none\",\n      strokeWidth: t,\n      stroke: i,\n      d: r(o())\n    });\n  });\nte.propTypes = {\n  path: m.func.isRequired,\n  graticule: m.func.isRequired,\n  lineWidth: m.number.isRequired,\n  lineColor: m.string.isRequired\n}, te.displayName = \"GeoGraticule\";\nvar ie = r(function (e) {\n  var r,\n    o = e.feature,\n    t = e.path,\n    i = e.fillColor,\n    n = e.borderWidth,\n    a = e.borderColor,\n    u = e.onClick,\n    l = e.onMouseEnter,\n    c = e.onMouseMove,\n    d = e.onMouseLeave;\n  return H(\"path\", {\n    fill: null != (r = null == o ? void 0 : o.fill) ? r : i,\n    strokeWidth: n,\n    stroke: a,\n    strokeLinejoin: \"bevel\",\n    d: t(o),\n    onMouseEnter: function (e) {\n      return l(o, e);\n    },\n    onMouseMove: function (e) {\n      return c(o, e);\n    },\n    onMouseLeave: function (e) {\n      return d(o, e);\n    },\n    onClick: function (e) {\n      return u(o, e);\n    }\n  }, o.id);\n});\nie.propTypes = {\n  feature: m.shape({\n    id: m.string.isRequired,\n    type: m.oneOf([\"Feature\"]).isRequired,\n    properties: m.object,\n    geometry: m.object.isRequired\n  }).isRequired,\n  path: m.func.isRequired,\n  fillColor: m.string.isRequired,\n  borderWidth: m.number.isRequired,\n  borderColor: m.string.isRequired,\n  onMouseEnter: m.func.isRequired,\n  onMouseMove: m.func.isRequired,\n  onMouseLeave: m.func.isRequired,\n  onClick: m.func.isRequired\n}, ie.displayName = \"GeoMapFeature\";\nvar ne = r(function (e) {\n  var r = e.width,\n    i = e.height,\n    n = e.margin,\n    u = e.features,\n    l = e.layers,\n    s = e.projectionType,\n    f = e.projectionScale,\n    h = e.projectionTranslation,\n    p = e.projectionRotation,\n    g = e.fillColor,\n    m = e.borderWidth,\n    C = e.borderColor,\n    b = e.enableGraticule,\n    y = e.graticuleLineWidth,\n    R = e.graticuleLineColor,\n    j = e.isInteractive,\n    q = e.onClick,\n    T = e.tooltip,\n    M = e.role,\n    W = c(r, i, n),\n    w = W.margin,\n    k = W.outerWidth,\n    F = W.outerHeight,\n    O = z({\n      width: r,\n      height: i,\n      projectionType: s,\n      projectionScale: f,\n      projectionTranslation: h,\n      projectionRotation: p,\n      fillColor: g,\n      borderWidth: m,\n      borderColor: C\n    }),\n    L = O.graticule,\n    E = O.path,\n    S = O.getFillColor,\n    G = O.getBorderWidth,\n    x = O.getBorderColor,\n    B = a(),\n    P = v(),\n    N = P.showTooltipFromEvent,\n    I = P.hideTooltip,\n    D = o(function (e, r) {\n      return j && q && q(e, r);\n    }, [j, q]),\n    K = o(function (e, r) {\n      return j && T && N(H(T, {\n        feature: e\n      }), r);\n    }, [j, N, T]),\n    V = o(function (e, r) {\n      return j && T && N(H(T, {\n        feature: e\n      }), r);\n    }, [j, N, T]),\n    A = o(function () {\n      return j && I();\n    }, [j, I]);\n  return H(d, {\n    width: k,\n    height: F,\n    margin: w,\n    theme: B,\n    role: M,\n    children: l.map(function (r, o) {\n      return \"graticule\" === r ? !0 !== b ? null : H(te, {\n        path: E,\n        graticule: L,\n        lineWidth: y,\n        lineColor: R\n      }, \"graticule\") : \"features\" === r ? H(t, {\n        children: u.map(function (e) {\n          return H(ie, {\n            feature: e,\n            path: E,\n            fillColor: S(e),\n            borderWidth: G(e),\n            borderColor: x(e),\n            onMouseEnter: K,\n            onMouseMove: V,\n            onMouseLeave: A,\n            onClick: D\n          }, e.id);\n        })\n      }, \"features\") : H(t, {\n        children: r(e)\n      }, o);\n    })\n  });\n});\nne.displayName = \"GeoMap\", ne.propTypes = J, ne.defaultProps = $;\nvar ae = s(ne),\n  ue = function (e) {\n    return H(f, {\n      children: function (r) {\n        var o = r.width,\n          t = r.height;\n        return H(ae, I({\n          width: o,\n          height: t\n        }, e));\n      }\n    });\n  },\n  le = function (e, r, o, t) {\n    var i = h(r, e),\n      n = i[0],\n      a = i[1];\n    return o.find(function (e) {\n      return x(e, t.invert([n, a]));\n    });\n  },\n  ce = r(function (e) {\n    var r = e.width,\n      t = e.height,\n      u = e.margin,\n      l = e.pixelRatio,\n      d = e.features,\n      s = e.layers,\n      f = e.projectionType,\n      h = e.projectionScale,\n      p = e.projectionTranslation,\n      g = e.projectionRotation,\n      m = e.fillColor,\n      C = e.borderWidth,\n      b = e.borderColor,\n      y = e.enableGraticule,\n      R = e.graticuleLineWidth,\n      j = e.graticuleLineColor,\n      q = e.isInteractive,\n      T = e.onClick,\n      M = e.onMouseMove,\n      W = e.tooltip,\n      w = i(null),\n      k = a(),\n      F = c(r, t, u),\n      O = F.margin,\n      L = F.outerWidth,\n      E = F.outerHeight,\n      S = z({\n        width: r,\n        height: t,\n        projectionType: f,\n        projectionScale: h,\n        projectionTranslation: p,\n        projectionRotation: g,\n        fillColor: m,\n        borderWidth: C,\n        borderColor: b\n      }),\n      G = S.projection,\n      x = S.graticule,\n      B = S.path,\n      P = S.getFillColor,\n      N = S.getBorderWidth,\n      I = S.getBorderColor;\n    n(function () {\n      if (w) {\n        w.current.width = L * l, w.current.height = E * l;\n        var r = w.current.getContext(\"2d\");\n        r.scale(l, l), r.fillStyle = k.background, r.fillRect(0, 0, L, E), r.translate(O.left, O.top), B.context(r), s.forEach(function (o) {\n          \"graticule\" === o ? !0 === y && (r.lineWidth = R, r.strokeStyle = j, r.beginPath(), B(x()), r.stroke()) : \"features\" === o ? d.forEach(function (e) {\n            r.beginPath(), B(e), r.fillStyle = P(e), r.fill();\n            var o = N(e);\n            o > 0 && (r.strokeStyle = I(e), r.lineWidth = o, r.stroke());\n          }) : o(r, e);\n        });\n      }\n    }, [w, L, E, O, l, k, B, x, P, N, I, d, s]);\n    var D = v(),\n      K = D.showTooltipFromEvent,\n      V = D.hideTooltip,\n      A = o(function (e) {\n        if (q && W) {\n          var r = le(e, w.current, d, G);\n          r ? K(H(W, {\n            feature: r\n          }), e) : V(), M && M(r || null, e);\n        }\n      }, [K, V, q, W, w, d, G]),\n      J = o(function () {\n        return q && V();\n      }, [q, V]),\n      Q = o(function (e) {\n        if (q && T) {\n          var r = le(e, w.current, d, G);\n          r && T(r, e);\n        }\n      }, [q, w, d, G, T]);\n    return H(\"canvas\", {\n      ref: w,\n      width: L * l,\n      height: E * l,\n      style: {\n        width: L,\n        height: E,\n        cursor: q ? \"auto\" : \"normal\"\n      },\n      onMouseMove: A,\n      onMouseLeave: J,\n      onClick: Q\n    });\n  });\nce.displatName = \"GeoMapCanvas\", ce.propTypes = Q, ce.defaultProps = _;\nvar de = s(ce),\n  se = function (e) {\n    return H(f, {\n      children: function (r) {\n        var o = r.width,\n          t = r.height;\n        return H(de, I({\n          width: o,\n          height: t\n        }, e));\n      }\n    });\n  },\n  fe = r(function (e) {\n    var r = e.width,\n      i = e.height,\n      n = e.margin,\n      u = e.features,\n      l = e.data,\n      s = e.match,\n      f = e.label,\n      h = e.value,\n      g = e.valueFormat,\n      m = e.projectionType,\n      C = e.projectionScale,\n      b = e.projectionTranslation,\n      y = e.projectionRotation,\n      R = e.colors,\n      j = e.domain,\n      q = e.unknownColor,\n      T = e.borderWidth,\n      M = e.borderColor,\n      W = e.enableGraticule,\n      w = e.graticuleLineWidth,\n      k = e.graticuleLineColor,\n      F = e.layers,\n      O = e.legends,\n      L = e.isInteractive,\n      E = e.onClick,\n      S = e.tooltip,\n      G = e.role,\n      x = e.defs,\n      B = void 0 === x ? re.defs : x,\n      N = e.fill,\n      D = void 0 === N ? re.fill : N,\n      V = c(r, i, n),\n      A = V.margin,\n      J = V.outerWidth,\n      Q = V.outerHeight,\n      U = z({\n        width: r,\n        height: i,\n        projectionType: m,\n        projectionScale: C,\n        projectionTranslation: b,\n        projectionRotation: y,\n        fillColor: function () {},\n        borderWidth: T,\n        borderColor: M\n      }),\n      X = U.graticule,\n      Y = U.path,\n      Z = U.getBorderWidth,\n      $ = U.getBorderColor,\n      _ = K({\n        features: u,\n        data: l,\n        match: s,\n        label: f,\n        value: h,\n        valueFormat: g,\n        colors: R,\n        unknownColor: q,\n        domain: j\n      }),\n      ee = _.getFillColor,\n      oe = _.boundFeatures,\n      ne = _.legendData,\n      ae = a(),\n      ue = p(B, oe, D, {\n        dataKey: \"data\",\n        targetKey: \"fill\"\n      }),\n      le = v(),\n      ce = le.showTooltipFromEvent,\n      de = le.hideTooltip,\n      se = o(function (e, r) {\n        return L && E && E(e, r);\n      }, [L, E]),\n      fe = o(function (e, r) {\n        return L && S && ce(H(S, {\n          feature: e\n        }), r);\n      }, [L, ce, S]),\n      he = o(function (e, r) {\n        return L && S && ce(H(S, {\n          feature: e\n        }), r);\n      }, [L, ce, S]),\n      pe = o(function () {\n        return L && de();\n      }, [L, de]);\n    return H(d, {\n      width: J,\n      height: Q,\n      margin: A,\n      theme: ae,\n      defs: ue,\n      role: G,\n      children: F.map(function (e, o) {\n        return \"graticule\" === e ? !0 !== W ? null : H(te, {\n          path: Y,\n          graticule: X,\n          lineWidth: w,\n          lineColor: k\n        }, \"graticule\") : \"features\" === e ? H(t, {\n          children: oe.map(function (e) {\n            return H(ie, {\n              feature: e,\n              path: Y,\n              fillColor: ee(e),\n              borderWidth: Z(e),\n              borderColor: $(e),\n              onMouseEnter: fe,\n              onMouseMove: he,\n              onMouseLeave: pe,\n              onClick: se\n            }, e.id);\n          })\n        }, \"features\") : \"legends\" === e ? O.map(function (e, o) {\n          return H(P, I({\n            containerWidth: r,\n            containerHeight: i,\n            data: ne\n          }, e), o);\n        }) : H(t, {\n          children: e({})\n        }, o);\n      })\n    });\n  });\nfe.displayName = \"Choropleth\", fe.propTypes = X, fe.defaultProps = re;\nvar he = s(fe),\n  pe = function (e) {\n    return H(f, {\n      children: function (r) {\n        var o = r.width,\n          t = r.height;\n        return H(he, I({\n          width: o,\n          height: t\n        }, e));\n      }\n    });\n  },\n  ge = function (e, r, o, t) {\n    var i = h(r, e),\n      n = i[0],\n      a = i[1];\n    return o.find(function (e) {\n      return x(e, t.invert([n, a]));\n    });\n  },\n  ve = r(function (e) {\n    var r = e.width,\n      t = e.height,\n      u = e.margin,\n      l = e.pixelRatio,\n      d = e.features,\n      s = e.data,\n      f = e.match,\n      h = e.label,\n      p = e.value,\n      g = e.valueFormat,\n      m = e.projectionType,\n      C = e.projectionScale,\n      b = e.projectionTranslation,\n      y = e.projectionRotation,\n      R = e.colors,\n      j = e.domain,\n      q = e.unknownColor,\n      T = e.borderWidth,\n      M = e.borderColor,\n      W = e.enableGraticule,\n      w = e.graticuleLineWidth,\n      k = e.graticuleLineColor,\n      F = e.layers,\n      O = e.legends,\n      L = e.isInteractive,\n      E = e.onClick,\n      S = e.onMouseMove,\n      G = e.tooltip,\n      x = i(null),\n      B = a(),\n      P = c(r, t, u),\n      D = P.margin,\n      V = P.outerWidth,\n      A = P.outerHeight,\n      J = z({\n        width: r,\n        height: t,\n        projectionType: m,\n        projectionScale: C,\n        projectionTranslation: b,\n        projectionRotation: y,\n        fillColor: function () {},\n        borderWidth: T,\n        borderColor: M\n      }),\n      Q = J.projection,\n      U = J.graticule,\n      X = J.path,\n      Y = J.getBorderWidth,\n      Z = J.getBorderColor,\n      $ = K({\n        features: d,\n        data: s,\n        match: f,\n        label: h,\n        value: p,\n        valueFormat: g,\n        colors: R,\n        unknownColor: q,\n        domain: j\n      }),\n      _ = $.getFillColor,\n      ee = $.boundFeatures,\n      re = $.legendData;\n    n(function () {\n      if (x) {\n        x.current.width = V * l, x.current.height = A * l;\n        var e = x.current.getContext(\"2d\");\n        e.scale(l, l), e.fillStyle = B.background, e.fillRect(0, 0, V, A), e.translate(D.left, D.top), X.context(e), F.forEach(function (o) {\n          \"graticule\" === o ? !0 === W && (e.lineWidth = w, e.strokeStyle = k, e.beginPath(), X(U()), e.stroke()) : \"features\" === o ? ee.forEach(function (r) {\n            e.beginPath(), X(r), e.fillStyle = _(r), e.fill();\n            var o = Y(r);\n            o > 0 && (e.strokeStyle = Z(r), e.lineWidth = o, e.stroke());\n          }) : \"legends\" === o && O.forEach(function (o) {\n            N(e, I({}, o, {\n              data: re,\n              containerWidth: r,\n              containerHeight: t,\n              theme: B\n            }));\n          });\n        });\n      }\n    }, [x, V, A, D, l, B, X, U, _, Y, Z, ee, O, F]);\n    var oe = v(),\n      te = oe.showTooltipFromEvent,\n      ie = oe.hideTooltip,\n      ne = o(function (e) {\n        if (L && G) {\n          var r = ge(e, x.current, ee, Q);\n          r ? te(H(G, {\n            feature: r\n          }), e) : ie(), S && S(r || null, e);\n        }\n      }, [te, ie, L, G, x, ee, Q]),\n      ae = o(function () {\n        return L && ie();\n      }, [L, ie]),\n      ue = o(function (e) {\n        if (L && E) {\n          var r = ge(e, x.current, ee, Q);\n          r && E(r, e);\n        }\n      }, [L, x, ee, Q, E]);\n    return H(\"canvas\", {\n      ref: x,\n      width: V * l,\n      height: A * l,\n      style: {\n        width: V,\n        height: A,\n        cursor: L ? \"auto\" : \"normal\"\n      },\n      onMouseMove: ne,\n      onMouseLeave: ae,\n      onClick: ue\n    });\n  });\nve.displayName = \"ChoroplethCanvas\", ve.propTypes = Y, ve.defaultProps = oe;\nvar me = s(ve),\n  Ce = function (e) {\n    return H(f, {\n      children: function (r) {\n        var o = r.width,\n          t = r.height;\n        return H(me, I({\n          width: o,\n          height: t\n        }, e));\n      }\n    });\n  };\nexport { he as Choropleth, me as ChoroplethCanvas, oe as ChoroplethCanvasDefaultProps, Y as ChoroplethCanvasPropTypes, re as ChoroplethDefaultProps, X as ChoroplethPropTypes, ae as GeoMap, de as GeoMapCanvas, _ as GeoMapCanvasDefaultProps, Q as GeoMapCanvasPropTypes, $ as GeoMapDefaultProps, J as GeoMapPropTypes, pe as ResponsiveChoropleth, Ce as ResponsiveChoroplethCanvas, ue as ResponsiveGeoMap, se as ResponsiveGeoMapCanvas, D as projectionById, K as useChoropleth, z as useGeoMap };","map":{"version":3,"mappings":"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","names":["projectionById","azimuthalEqualArea","geoAzimuthalEqualArea","azimuthalEquidistant","geoAzimuthalEquidistant","gnomonic","geoGnomonic","orthographic","geoOrthographic","stereographic","geoStereographic","equalEarth","geoEqualEarth","equirectangular","geoEquirectangular","mercator","geoMercator","transverseMercator","geoTransverseMercator","naturalEarth1","geoNaturalEarth1","useGeoMap","width","height","projectionType","projectionScale","projectionTranslation","projectionRotation","fillColor","borderWidth","borderColor","projection","useMemo","scale","translate","rotate","path","geoPath","graticule","geoGraticule","theme","useTheme","getBorderWidth","getBorderColor","useInheritedColor","getFillColor","useChoropleth","features","data","match","label","value","valueFormat","colors","unknownColor","domain","findMatchingDatum","_isFunction","feature","datum","featureKey","_get","datumKey","getLabel","getValue","valueFormatter","undefined","d","format","colorScale","guessQuantizeColorScale","boundFeatures","map","find","datumValue","featureWithData","formattedValue","color","legendData","useQuantizeColorScaleLegendData","ChoroplethTooltip","memo","_jsx","BasicTooltip","id","enableChip","propTypes","PropTypes","object","isRequired","displayName","commonPropTypes","arrayOf","shape","string","type","oneOf","properties","geometry","Object","keys","number","oneOfType","func","inheritedColorPropType","enableGraticule","bool","graticuleLineWidth","graticuleLineColor","isInteractive","onMouseEnter","onMouseMove","onMouseLeave","onClick","tooltip","any","layers","GeoMapPropTypes","role","GeoMapCanvasPropTypes","pixelRatio","commonChoroplethPropTypes","quantizeColorScalePropType","ChoroplethPropTypes","ChoroplethCanvasPropTypes","commonDefaultProps","legends","fill","defs","GeoMapDefaultProps","GeoMapCanvasDefaultProps","window","devicePixelRatio","commonChoroplethDefaultProps","ChoroplethDefaultProps","ChoroplethCanvasDefaultProps","GeoGraticule","lineWidth","lineColor","strokeWidth","stroke","GeoMapFeature","strokeLinejoin","event","GeoMap","props","partialMargin","margin","Tooltip","useDimensions","outerWidth","outerHeight","useTooltip","showTooltipFromEvent","hideTooltip","handleClick","useCallback","handleMouseEnter","handleMouseMove","handleMouseLeave","SvgWrapper","layer","i","Fragment","defaultProps","withContainer","ResponsiveGeoMap","ResponsiveWrapper","getFeatureFromMouseEvent","el","getRelativeCursor","x","y","f","geoContains","invert","GeoMapCanvas","canvasEl","useRef","useEffect","current","ctx","getContext","fillStyle","background","fillRect","left","top","context","forEach","strokeStyle","beginPath","ref","style","cursor","displatName","ResponsiveGeoMapCanvas","Choropleth","boundDefs","bindDefs","dataKey","targetKey","le","legend","BoxLegendSvg","containerWidth","containerHeight","ResponsiveChoropleth","ChoroplethCanvas","renderLegendToCanvas","ResponsiveChoroplethCanvas"],"sources":["/Users/dabere/Desktop/Dashboard ui/dashboard/node_modules/@nivo/geo/src/hooks.js","/Users/dabere/Desktop/Dashboard ui/dashboard/node_modules/@nivo/geo/src/ChoroplethTooltip.js","/Users/dabere/Desktop/Dashboard ui/dashboard/node_modules/@nivo/geo/src/props.js","/Users/dabere/Desktop/Dashboard ui/dashboard/node_modules/@nivo/geo/src/GeoGraticule.js","/Users/dabere/Desktop/Dashboard ui/dashboard/node_modules/@nivo/geo/src/GeoMapFeature.js","/Users/dabere/Desktop/Dashboard ui/dashboard/node_modules/@nivo/geo/src/GeoMap.js","/Users/dabere/Desktop/Dashboard ui/dashboard/node_modules/@nivo/geo/src/ResponsiveGeoMap.js","/Users/dabere/Desktop/Dashboard ui/dashboard/node_modules/@nivo/geo/src/GeoMapCanvas.js","/Users/dabere/Desktop/Dashboard ui/dashboard/node_modules/@nivo/geo/src/ResponsiveGeoMapCanvas.js","/Users/dabere/Desktop/Dashboard ui/dashboard/node_modules/@nivo/geo/src/Choropleth.js","/Users/dabere/Desktop/Dashboard ui/dashboard/node_modules/@nivo/geo/src/ResponsiveChoropleth.js","/Users/dabere/Desktop/Dashboard ui/dashboard/node_modules/@nivo/geo/src/ChoroplethCanvas.js","/Users/dabere/Desktop/Dashboard ui/dashboard/node_modules/@nivo/geo/src/ResponsiveChoroplethCanvas.js"],"sourcesContent":["/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { useMemo } from 'react'\nimport { isFunction, get } from 'lodash'\nimport { format } from 'd3-format'\nimport {\n    geoPath,\n    geoAzimuthalEqualArea,\n    geoAzimuthalEquidistant,\n    geoGnomonic,\n    geoOrthographic,\n    geoStereographic,\n    geoEqualEarth,\n    geoEquirectangular,\n    geoMercator,\n    geoTransverseMercator,\n    geoNaturalEarth1,\n    geoGraticule,\n} from 'd3-geo'\nimport { guessQuantizeColorScale, useTheme } from '@nivo/core'\nimport { useInheritedColor } from '@nivo/colors'\nimport { useQuantizeColorScaleLegendData } from '@nivo/legends'\n\nexport const projectionById = {\n    azimuthalEqualArea: geoAzimuthalEqualArea,\n    azimuthalEquidistant: geoAzimuthalEquidistant,\n    gnomonic: geoGnomonic,\n    orthographic: geoOrthographic,\n    stereographic: geoStereographic,\n    equalEarth: geoEqualEarth,\n    equirectangular: geoEquirectangular,\n    mercator: geoMercator,\n    transverseMercator: geoTransverseMercator,\n    naturalEarth1: geoNaturalEarth1,\n}\n\nexport const useGeoMap = ({\n    width,\n    height,\n    projectionType,\n    projectionScale,\n    projectionTranslation,\n    projectionRotation,\n    fillColor,\n    borderWidth,\n    borderColor,\n}) => {\n    const projection = useMemo(() => {\n        return projectionById[projectionType]()\n            .scale(projectionScale)\n            .translate([width * projectionTranslation[0], height * projectionTranslation[1]])\n            .rotate(projectionRotation)\n    }, [\n        width,\n        height,\n        projectionType,\n        projectionScale,\n        projectionTranslation[0],\n        projectionTranslation[1],\n        projectionRotation[0],\n        projectionRotation[1],\n        projectionRotation[2],\n    ])\n    const path = useMemo(() => geoPath(projection), [projection])\n    const graticule = useMemo(() => geoGraticule())\n\n    const theme = useTheme()\n    const getBorderWidth = useMemo(\n        () => (typeof borderWidth === 'function' ? borderWidth : () => borderWidth),\n        [borderWidth]\n    )\n    const getBorderColor = useInheritedColor(borderColor, theme)\n    const getFillColor = useMemo(\n        () => (typeof fillColor === 'function' ? fillColor : () => fillColor),\n        [fillColor]\n    )\n\n    return {\n        projection,\n        path,\n        graticule,\n        getBorderWidth,\n        getBorderColor,\n        getFillColor,\n    }\n}\n\nexport const useChoropleth = ({\n    features,\n    data,\n    match,\n    label,\n    value,\n    valueFormat,\n    colors,\n    unknownColor,\n    domain,\n}) => {\n    const findMatchingDatum = useMemo(() => {\n        if (isFunction(match)) return match\n        return (feature, datum) => {\n            const featureKey = get(feature, match)\n            const datumKey = get(datum, match)\n\n            return featureKey && featureKey === datumKey\n        }\n    }, [match])\n    const getLabel = useMemo(\n        () => (isFunction(label) ? label : datum => get(datum, label)),\n        [label]\n    )\n    const getValue = useMemo(\n        () => (isFunction(value) ? value : datum => get(datum, value)),\n        [value]\n    )\n    const valueFormatter = useMemo(() => {\n        if (valueFormat === undefined) return d => d\n        if (isFunction(valueFormat)) return valueFormat\n        return format(valueFormat)\n    }, [valueFormat])\n\n    const colorScale = useMemo(\n        () => guessQuantizeColorScale(colors).domain(domain),\n        [colors, domain]\n    )\n    const getFillColor = useMemo(() => {\n        return feature => {\n            if (feature.value === undefined) return unknownColor\n            return colorScale(feature.value)\n        }\n    }, [colorScale, unknownColor])\n\n    const boundFeatures = useMemo(\n        () =>\n            features.map(feature => {\n                const datum = data.find(datum => findMatchingDatum(feature, datum))\n                const datumValue = getValue(datum)\n\n                if (datum) {\n                    const featureWithData = {\n                        ...feature,\n                        data: datum,\n                        value: datumValue,\n                        formattedValue: valueFormatter(datumValue),\n                    }\n                    featureWithData.color = getFillColor(featureWithData)\n                    featureWithData.label = getLabel(featureWithData)\n\n                    return featureWithData\n                }\n\n                return feature\n            }),\n        [features, data, findMatchingDatum, getValue, valueFormatter, getFillColor]\n    )\n\n    const legendData = useQuantizeColorScaleLegendData({\n        scale: colorScale,\n        valueFormat: valueFormatter,\n    })\n\n    return {\n        colorScale,\n        getFillColor,\n        boundFeatures,\n        valueFormatter,\n        legendData,\n    }\n}\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { memo } from 'react'\nimport PropTypes from 'prop-types'\nimport { BasicTooltip } from '@nivo/tooltip'\n\nconst ChoroplethTooltip = memo(({ feature }) => {\n    if (feature.data === undefined) return null\n\n    return (\n        <BasicTooltip\n            id={feature.label}\n            color={feature.color}\n            enableChip={true}\n            value={feature.formattedValue}\n        />\n    )\n})\n\nChoroplethTooltip.propTypes = {\n    feature: PropTypes.object.isRequired,\n}\n\nChoroplethTooltip.displayName = 'ChoroplethTooltip'\n\nexport default ChoroplethTooltip\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport PropTypes from 'prop-types'\nimport { quantizeColorScalePropType } from '@nivo/core'\nimport { inheritedColorPropType } from '@nivo/colors'\nimport { projectionById } from './hooks'\nimport ChoroplethTooltip from './ChoroplethTooltip'\n\nconst commonPropTypes = {\n    features: PropTypes.arrayOf(\n        PropTypes.shape({\n            id: PropTypes.string.isRequired,\n            type: PropTypes.oneOf(['Feature']).isRequired,\n            properties: PropTypes.object,\n            geometry: PropTypes.object.isRequired,\n        })\n    ).isRequired,\n\n    projectionType: PropTypes.oneOf(Object.keys(projectionById)).isRequired,\n    projectionScale: PropTypes.number.isRequired,\n    projectionTranslation: PropTypes.arrayOf(PropTypes.number).isRequired,\n    projectionRotation: PropTypes.arrayOf(PropTypes.number).isRequired,\n\n    fillColor: PropTypes.oneOfType([PropTypes.string, PropTypes.func]).isRequired,\n    borderWidth: PropTypes.oneOfType([PropTypes.number, PropTypes.func]).isRequired,\n    borderColor: inheritedColorPropType.isRequired,\n\n    enableGraticule: PropTypes.bool.isRequired,\n    graticuleLineWidth: PropTypes.number.isRequired,\n    graticuleLineColor: PropTypes.string.isRequired,\n\n    isInteractive: PropTypes.bool.isRequired,\n    onMouseEnter: PropTypes.func.isRequired,\n    onMouseMove: PropTypes.func.isRequired,\n    onMouseLeave: PropTypes.func.isRequired,\n    onClick: PropTypes.func.isRequired,\n    tooltip: PropTypes.any,\n\n    layers: PropTypes.arrayOf(\n        PropTypes.oneOfType([PropTypes.oneOf(['graticule', 'features']), PropTypes.func])\n    ).isRequired,\n}\n\nexport const GeoMapPropTypes = {\n    ...commonPropTypes,\n    role: PropTypes.string.isRequired,\n}\n\nexport const GeoMapCanvasPropTypes = {\n    pixelRatio: PropTypes.number.isRequired,\n    ...commonPropTypes,\n}\n\nconst commonChoroplethPropTypes = {\n    data: PropTypes.arrayOf(PropTypes.object).isRequired,\n    match: PropTypes.oneOfType([PropTypes.string, PropTypes.func]).isRequired,\n    label: PropTypes.oneOfType([PropTypes.string, PropTypes.func]).isRequired,\n    value: PropTypes.oneOfType([PropTypes.string, PropTypes.func]).isRequired,\n    valueFormat: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),\n    colors: quantizeColorScalePropType.isRequired,\n    domain: PropTypes.arrayOf(PropTypes.number).isRequired,\n    unknownColor: PropTypes.string.isRequired,\n    layers: PropTypes.arrayOf(\n        PropTypes.oneOfType([PropTypes.oneOf(['graticule', 'features', 'legends']), PropTypes.func])\n    ).isRequired,\n}\n\nexport const ChoroplethPropTypes = {\n    ...GeoMapPropTypes,\n    ...commonChoroplethPropTypes,\n    role: PropTypes.string.isRequired,\n}\n\nexport const ChoroplethCanvasPropTypes = {\n    ...GeoMapCanvasPropTypes,\n    ...commonChoroplethPropTypes,\n}\n\nconst commonDefaultProps = {\n    projectionType: 'mercator',\n    projectionScale: 100,\n    projectionTranslation: [0.5, 0.5],\n    projectionRotation: [0, 0, 0],\n\n    enableGraticule: false,\n    graticuleLineWidth: 0.5,\n    graticuleLineColor: '#999999',\n\n    fillColor: '#dddddd',\n    borderWidth: 0,\n    borderColor: '#000000',\n\n    isInteractive: true,\n    onMouseEnter: () => {},\n    onMouseLeave: () => {},\n    onMouseMove: () => {},\n    onClick: () => {},\n\n    layers: ['graticule', 'features'],\n    legends: [],\n\n    fill: [],\n    defs: [],\n}\n\nexport const GeoMapDefaultProps = {\n    ...commonDefaultProps,\n    role: 'img',\n}\n\nexport const GeoMapCanvasDefaultProps = {\n    ...commonDefaultProps,\n    pixelRatio: typeof window !== 'undefined' ? window.devicePixelRatio || 1 : 1,\n}\n\nconst commonChoroplethDefaultProps = {\n    match: 'id',\n    label: 'id',\n    value: 'value',\n    colors: 'PuBuGn',\n    unknownColor: '#999',\n    tooltip: ChoroplethTooltip,\n    layers: ['graticule', 'features', 'legends'],\n}\n\nexport const ChoroplethDefaultProps = {\n    ...GeoMapDefaultProps,\n    ...commonChoroplethDefaultProps,\n    role: 'img',\n}\n\nexport const ChoroplethCanvasDefaultProps = {\n    ...GeoMapCanvasDefaultProps,\n    ...commonChoroplethDefaultProps,\n}\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { memo } from 'react'\nimport PropTypes from 'prop-types'\n\nconst GeoGraticule = memo(({ path, graticule, lineWidth, lineColor }) => {\n    return <path fill=\"none\" strokeWidth={lineWidth} stroke={lineColor} d={path(graticule())} />\n})\n\nGeoGraticule.propTypes = {\n    path: PropTypes.func.isRequired,\n    graticule: PropTypes.func.isRequired,\n    lineWidth: PropTypes.number.isRequired,\n    lineColor: PropTypes.string.isRequired,\n}\n\nGeoGraticule.displayName = 'GeoGraticule'\n\nexport default GeoGraticule\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { memo } from 'react'\nimport PropTypes from 'prop-types'\n\nconst GeoMapFeature = memo(\n    ({\n        feature,\n        path,\n        fillColor,\n        borderWidth,\n        borderColor,\n        onClick,\n        onMouseEnter,\n        onMouseMove,\n        onMouseLeave,\n    }) => {\n        return (\n            <path\n                key={feature.id}\n                fill={feature?.fill ?? fillColor}\n                strokeWidth={borderWidth}\n                stroke={borderColor}\n                strokeLinejoin=\"bevel\"\n                d={path(feature)}\n                onMouseEnter={event => onMouseEnter(feature, event)}\n                onMouseMove={event => onMouseMove(feature, event)}\n                onMouseLeave={event => onMouseLeave(feature, event)}\n                onClick={event => onClick(feature, event)}\n            />\n        )\n    }\n)\n\nGeoMapFeature.propTypes = {\n    feature: PropTypes.shape({\n        id: PropTypes.string.isRequired,\n        type: PropTypes.oneOf(['Feature']).isRequired,\n        properties: PropTypes.object,\n        geometry: PropTypes.object.isRequired,\n    }).isRequired,\n    path: PropTypes.func.isRequired,\n\n    fillColor: PropTypes.string.isRequired,\n    borderWidth: PropTypes.number.isRequired,\n    borderColor: PropTypes.string.isRequired,\n\n    onMouseEnter: PropTypes.func.isRequired,\n    onMouseMove: PropTypes.func.isRequired,\n    onMouseLeave: PropTypes.func.isRequired,\n    onClick: PropTypes.func.isRequired,\n}\n\nGeoMapFeature.displayName = 'GeoMapFeature'\n\nexport default GeoMapFeature\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { Fragment, useCallback, memo } from 'react'\nimport { SvgWrapper, withContainer, useDimensions, useTheme } from '@nivo/core'\nimport { useTooltip } from '@nivo/tooltip'\nimport { GeoMapPropTypes, GeoMapDefaultProps } from './props'\nimport GeoGraticule from './GeoGraticule'\nimport GeoMapFeature from './GeoMapFeature'\nimport { useGeoMap } from './hooks'\n\nconst GeoMap = memo(props => {\n    const {\n        width,\n        height,\n        margin: partialMargin,\n        features,\n        layers,\n        projectionType,\n        projectionScale,\n        projectionTranslation,\n        projectionRotation,\n        fillColor,\n        borderWidth,\n        borderColor,\n        enableGraticule,\n        graticuleLineWidth,\n        graticuleLineColor,\n        isInteractive,\n        onClick,\n        tooltip: Tooltip,\n        role,\n    } = props\n    const { margin, outerWidth, outerHeight } = useDimensions(width, height, partialMargin)\n    const { graticule, path, getFillColor, getBorderWidth, getBorderColor } = useGeoMap({\n        width,\n        height,\n        projectionType,\n        projectionScale,\n        projectionTranslation,\n        projectionRotation,\n        fillColor,\n        borderWidth,\n        borderColor,\n    })\n\n    const theme = useTheme()\n\n    const { showTooltipFromEvent, hideTooltip } = useTooltip()\n    const handleClick = useCallback(\n        (feature, event) => isInteractive && onClick && onClick(feature, event),\n        [isInteractive, onClick]\n    )\n    const handleMouseEnter = useCallback(\n        (feature, event) =>\n            isInteractive && Tooltip && showTooltipFromEvent(<Tooltip feature={feature} />, event),\n        [isInteractive, showTooltipFromEvent, Tooltip]\n    )\n    const handleMouseMove = useCallback(\n        (feature, event) =>\n            isInteractive && Tooltip && showTooltipFromEvent(<Tooltip feature={feature} />, event),\n        [isInteractive, showTooltipFromEvent, Tooltip]\n    )\n    const handleMouseLeave = useCallback(\n        () => isInteractive && hideTooltip(),\n        [isInteractive, hideTooltip]\n    )\n\n    return (\n        <SvgWrapper\n            width={outerWidth}\n            height={outerHeight}\n            margin={margin}\n            theme={theme}\n            role={role}\n        >\n            {layers.map((layer, i) => {\n                if (layer === 'graticule') {\n                    if (enableGraticule !== true) return null\n\n                    return (\n                        <GeoGraticule\n                            key=\"graticule\"\n                            path={path}\n                            graticule={graticule}\n                            lineWidth={graticuleLineWidth}\n                            lineColor={graticuleLineColor}\n                        />\n                    )\n                }\n                if (layer === 'features') {\n                    return (\n                        <Fragment key=\"features\">\n                            {features.map(feature => (\n                                <GeoMapFeature\n                                    key={feature.id}\n                                    feature={feature}\n                                    path={path}\n                                    fillColor={getFillColor(feature)}\n                                    borderWidth={getBorderWidth(feature)}\n                                    borderColor={getBorderColor(feature)}\n                                    onMouseEnter={handleMouseEnter}\n                                    onMouseMove={handleMouseMove}\n                                    onMouseLeave={handleMouseLeave}\n                                    onClick={handleClick}\n                                />\n                            ))}\n                        </Fragment>\n                    )\n                }\n\n                return <Fragment key={i}>{layer(props)}</Fragment>\n            })}\n        </SvgWrapper>\n    )\n})\n\nGeoMap.displayName = 'GeoMap'\nGeoMap.propTypes = GeoMapPropTypes\nGeoMap.defaultProps = GeoMapDefaultProps\n\nexport default withContainer(GeoMap)\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { ResponsiveWrapper } from '@nivo/core'\nimport GeoMap from './GeoMap'\n\nconst ResponsiveGeoMap = props => (\n    <ResponsiveWrapper>\n        {({ width, height }) => <GeoMap width={width} height={height} {...props} />}\n    </ResponsiveWrapper>\n)\n\nexport default ResponsiveGeoMap\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { memo, useRef, useEffect, useCallback } from 'react'\nimport { geoContains } from 'd3-geo'\nimport { getRelativeCursor, withContainer, useDimensions, useTheme } from '@nivo/core'\nimport { useTooltip } from '@nivo/tooltip'\nimport { GeoMapCanvasDefaultProps, GeoMapCanvasPropTypes } from './props'\nimport { useGeoMap } from './hooks'\n\nconst getFeatureFromMouseEvent = (event, el, features, projection) => {\n    const [x, y] = getRelativeCursor(el, event)\n\n    return features.find(f => geoContains(f, projection.invert([x, y])))\n}\n\nconst GeoMapCanvas = memo(props => {\n    const {\n        width,\n        height,\n        margin: partialMargin,\n        pixelRatio,\n        features,\n        layers,\n\n        projectionType,\n        projectionScale,\n        projectionTranslation,\n        projectionRotation,\n\n        fillColor,\n        borderWidth,\n        borderColor,\n\n        enableGraticule,\n        graticuleLineWidth,\n        graticuleLineColor,\n\n        isInteractive,\n        onClick,\n        onMouseMove,\n        tooltip: Tooltip,\n    } = props\n\n    const canvasEl = useRef(null)\n    const theme = useTheme()\n    const { margin, outerWidth, outerHeight } = useDimensions(width, height, partialMargin)\n    const { projection, graticule, path, getFillColor, getBorderWidth, getBorderColor } = useGeoMap(\n        {\n            width,\n            height,\n            projectionType,\n            projectionScale,\n            projectionTranslation,\n            projectionRotation,\n            fillColor,\n            borderWidth,\n            borderColor,\n        }\n    )\n\n    useEffect(() => {\n        if (!canvasEl) return\n\n        canvasEl.current.width = outerWidth * pixelRatio\n        canvasEl.current.height = outerHeight * pixelRatio\n\n        const ctx = canvasEl.current.getContext('2d')\n\n        ctx.scale(pixelRatio, pixelRatio)\n\n        ctx.fillStyle = theme.background\n        ctx.fillRect(0, 0, outerWidth, outerHeight)\n        ctx.translate(margin.left, margin.top)\n\n        path.context(ctx)\n\n        layers.forEach(layer => {\n            if (layer === 'graticule') {\n                if (enableGraticule === true) {\n                    ctx.lineWidth = graticuleLineWidth\n                    ctx.strokeStyle = graticuleLineColor\n                    ctx.beginPath()\n                    path(graticule())\n                    ctx.stroke()\n                }\n            } else if (layer === 'features') {\n                features.forEach(feature => {\n                    ctx.beginPath()\n                    path(feature)\n                    ctx.fillStyle = getFillColor(feature)\n                    ctx.fill()\n\n                    const borderWidth = getBorderWidth(feature)\n                    if (borderWidth > 0) {\n                        ctx.strokeStyle = getBorderColor(feature)\n                        ctx.lineWidth = borderWidth\n                        ctx.stroke()\n                    }\n                })\n            } else {\n                layer(ctx, props)\n            }\n        })\n    }, [\n        canvasEl,\n        outerWidth,\n        outerHeight,\n        margin,\n        pixelRatio,\n        theme,\n        path,\n        graticule,\n        getFillColor,\n        getBorderWidth,\n        getBorderColor,\n        features,\n        layers,\n    ])\n\n    const { showTooltipFromEvent, hideTooltip } = useTooltip()\n    const handleMouseMove = useCallback(\n        event => {\n            if (!isInteractive || !Tooltip) return\n\n            const feature = getFeatureFromMouseEvent(event, canvasEl.current, features, projection)\n            if (feature) {\n                showTooltipFromEvent(<Tooltip feature={feature} />, event)\n            } else {\n                hideTooltip()\n            }\n            onMouseMove && onMouseMove(feature || null, event)\n        },\n        [showTooltipFromEvent, hideTooltip, isInteractive, Tooltip, canvasEl, features, projection]\n    )\n    const handleMouseLeave = useCallback(\n        () => isInteractive && hideTooltip(),\n        [isInteractive, hideTooltip]\n    )\n    const handleClick = useCallback(\n        event => {\n            if (!isInteractive || !onClick) return\n\n            const feature = getFeatureFromMouseEvent(event, canvasEl.current, features, projection)\n            if (feature) {\n                onClick(feature, event)\n            }\n        },\n        [isInteractive, canvasEl, features, projection, onClick]\n    )\n\n    return (\n        <canvas\n            ref={canvasEl}\n            width={outerWidth * pixelRatio}\n            height={outerHeight * pixelRatio}\n            style={{\n                width: outerWidth,\n                height: outerHeight,\n                cursor: isInteractive ? 'auto' : 'normal',\n            }}\n            onMouseMove={handleMouseMove}\n            onMouseLeave={handleMouseLeave}\n            onClick={handleClick}\n        />\n    )\n})\n\nGeoMapCanvas.displatName = 'GeoMapCanvas'\nGeoMapCanvas.propTypes = GeoMapCanvasPropTypes\nGeoMapCanvas.defaultProps = GeoMapCanvasDefaultProps\n\nexport default withContainer(GeoMapCanvas)\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { ResponsiveWrapper } from '@nivo/core'\nimport GeoMapCanvas from './GeoMapCanvas'\n\nconst ResponsiveGeoMapCanvas = props => (\n    <ResponsiveWrapper>\n        {({ width, height }) => <GeoMapCanvas width={width} height={height} {...props} />}\n    </ResponsiveWrapper>\n)\n\nexport default ResponsiveGeoMapCanvas\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { memo, Fragment, useCallback } from 'react'\nimport { SvgWrapper, withContainer, useDimensions, useTheme, bindDefs } from '@nivo/core'\nimport { BoxLegendSvg } from '@nivo/legends'\nimport { useTooltip } from '@nivo/tooltip'\nimport { ChoroplethPropTypes, ChoroplethDefaultProps } from './props'\nimport GeoGraticule from './GeoGraticule'\nimport GeoMapFeature from './GeoMapFeature'\nimport { useGeoMap, useChoropleth } from './hooks'\n\nconst Choropleth = memo(\n    ({\n        width,\n        height,\n        margin: partialMargin,\n        features,\n        data,\n        match,\n        label,\n        value,\n        valueFormat,\n        projectionType,\n        projectionScale,\n        projectionTranslation,\n        projectionRotation,\n        colors,\n        domain,\n        unknownColor,\n        borderWidth,\n        borderColor,\n        enableGraticule,\n        graticuleLineWidth,\n        graticuleLineColor,\n        layers,\n        legends,\n        isInteractive,\n        onClick,\n        tooltip: Tooltip,\n        role,\n        defs = ChoroplethDefaultProps.defs,\n        fill = ChoroplethDefaultProps.fill,\n    }) => {\n        const { margin, outerWidth, outerHeight } = useDimensions(width, height, partialMargin)\n        const { graticule, path, getBorderWidth, getBorderColor } = useGeoMap({\n            width,\n            height,\n            projectionType,\n            projectionScale,\n            projectionTranslation,\n            projectionRotation,\n            fillColor: () => {},\n            borderWidth,\n            borderColor,\n        })\n        const { getFillColor, boundFeatures, legendData } = useChoropleth({\n            features,\n            data,\n            match,\n            label,\n            value,\n            valueFormat,\n            colors,\n            unknownColor,\n            domain,\n        })\n\n        const theme = useTheme()\n\n        const boundDefs = bindDefs(defs, boundFeatures, fill, {\n            dataKey: 'data',\n            targetKey: 'fill',\n        })\n\n        const { showTooltipFromEvent, hideTooltip } = useTooltip()\n        const handleClick = useCallback(\n            (feature, event) => isInteractive && onClick && onClick(feature, event),\n            [isInteractive, onClick]\n        )\n        const handleMouseEnter = useCallback(\n            (feature, event) =>\n                isInteractive &&\n                Tooltip &&\n                showTooltipFromEvent(<Tooltip feature={feature} />, event),\n            [isInteractive, showTooltipFromEvent, Tooltip]\n        )\n        const handleMouseMove = useCallback(\n            (feature, event) =>\n                isInteractive &&\n                Tooltip &&\n                showTooltipFromEvent(<Tooltip feature={feature} />, event),\n            [isInteractive, showTooltipFromEvent, Tooltip]\n        )\n        const handleMouseLeave = useCallback(\n            () => isInteractive && hideTooltip(),\n            [isInteractive, hideTooltip]\n        )\n\n        return (\n            <SvgWrapper\n                width={outerWidth}\n                height={outerHeight}\n                margin={margin}\n                theme={theme}\n                defs={boundDefs}\n                role={role}\n            >\n                {layers.map((layer, i) => {\n                    if (layer === 'graticule') {\n                        if (enableGraticule !== true) return null\n\n                        return (\n                            <GeoGraticule\n                                key=\"graticule\"\n                                path={path}\n                                graticule={graticule}\n                                lineWidth={graticuleLineWidth}\n                                lineColor={graticuleLineColor}\n                            />\n                        )\n                    }\n                    if (layer === 'features') {\n                        return (\n                            <Fragment key=\"features\">\n                                {boundFeatures.map(feature => (\n                                    <GeoMapFeature\n                                        key={feature.id}\n                                        feature={feature}\n                                        path={path}\n                                        fillColor={getFillColor(feature)}\n                                        borderWidth={getBorderWidth(feature)}\n                                        borderColor={getBorderColor(feature)}\n                                        onMouseEnter={handleMouseEnter}\n                                        onMouseMove={handleMouseMove}\n                                        onMouseLeave={handleMouseLeave}\n                                        onClick={handleClick}\n                                    />\n                                ))}\n                            </Fragment>\n                        )\n                    }\n                    if (layer === 'legends') {\n                        return legends.map((legend, i) => {\n                            return (\n                                <BoxLegendSvg\n                                    key={i}\n                                    containerWidth={width}\n                                    containerHeight={height}\n                                    data={legendData}\n                                    {...legend}\n                                />\n                            )\n                        })\n                    }\n\n                    return <Fragment key={i}>{layer({})}</Fragment>\n                })}\n            </SvgWrapper>\n        )\n    }\n)\n\nChoropleth.displayName = 'Choropleth'\nChoropleth.propTypes = ChoroplethPropTypes\nChoropleth.defaultProps = ChoroplethDefaultProps\n\nexport default withContainer(Choropleth)\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { ResponsiveWrapper } from '@nivo/core'\nimport Choropleth from './Choropleth'\n\nconst ResponsiveChoropleth = props => (\n    <ResponsiveWrapper>\n        {({ width, height }) => <Choropleth width={width} height={height} {...props} />}\n    </ResponsiveWrapper>\n)\n\nexport default ResponsiveChoropleth\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { memo, useRef, useEffect, useCallback } from 'react'\nimport { geoContains } from 'd3-geo'\nimport { getRelativeCursor, withContainer, useDimensions, useTheme } from '@nivo/core'\nimport { renderLegendToCanvas } from '@nivo/legends'\nimport { useTooltip } from '@nivo/tooltip'\nimport { ChoroplethCanvasDefaultProps, ChoroplethCanvasPropTypes } from './props'\nimport { useGeoMap, useChoropleth } from './hooks'\n\nconst getFeatureFromMouseEvent = (event, el, features, projection) => {\n    const [x, y] = getRelativeCursor(el, event)\n\n    return features.find(f => geoContains(f, projection.invert([x, y])))\n}\n\nconst ChoroplethCanvas = memo(\n    ({\n        width,\n        height,\n        margin: partialMargin,\n        pixelRatio,\n        features,\n        data,\n        match,\n        label,\n        value,\n        valueFormat,\n        projectionType,\n        projectionScale,\n        projectionTranslation,\n        projectionRotation,\n        colors,\n        domain,\n        unknownColor,\n        borderWidth,\n        borderColor,\n        enableGraticule,\n        graticuleLineWidth,\n        graticuleLineColor,\n        layers,\n        legends,\n        isInteractive,\n        onClick,\n        onMouseMove,\n        tooltip: Tooltip,\n    }) => {\n        const canvasEl = useRef(null)\n        const theme = useTheme()\n        const { margin, outerWidth, outerHeight } = useDimensions(width, height, partialMargin)\n        const { projection, graticule, path, getBorderWidth, getBorderColor } = useGeoMap({\n            width,\n            height,\n            projectionType,\n            projectionScale,\n            projectionTranslation,\n            projectionRotation,\n            fillColor: () => {},\n            borderWidth,\n            borderColor,\n        })\n        const { getFillColor, boundFeatures, legendData } = useChoropleth({\n            features,\n            data,\n            match,\n            label,\n            value,\n            valueFormat,\n            colors,\n            unknownColor,\n            domain,\n        })\n\n        useEffect(() => {\n            if (!canvasEl) return\n\n            canvasEl.current.width = outerWidth * pixelRatio\n            canvasEl.current.height = outerHeight * pixelRatio\n\n            const ctx = canvasEl.current.getContext('2d')\n\n            ctx.scale(pixelRatio, pixelRatio)\n\n            ctx.fillStyle = theme.background\n            ctx.fillRect(0, 0, outerWidth, outerHeight)\n            ctx.translate(margin.left, margin.top)\n\n            path.context(ctx)\n\n            layers.forEach(layer => {\n                if (layer === 'graticule') {\n                    if (enableGraticule === true) {\n                        ctx.lineWidth = graticuleLineWidth\n                        ctx.strokeStyle = graticuleLineColor\n                        ctx.beginPath()\n                        path(graticule())\n                        ctx.stroke()\n                    }\n                } else if (layer === 'features') {\n                    boundFeatures.forEach(feature => {\n                        ctx.beginPath()\n                        path(feature)\n                        ctx.fillStyle = getFillColor(feature)\n                        ctx.fill()\n\n                        const borderWidth = getBorderWidth(feature)\n                        if (borderWidth > 0) {\n                            ctx.strokeStyle = getBorderColor(feature)\n                            ctx.lineWidth = borderWidth\n                            ctx.stroke()\n                        }\n                    })\n                } else if (layer === 'legends') {\n                    legends.forEach(legend => {\n                        renderLegendToCanvas(ctx, {\n                            ...legend,\n                            data: legendData,\n                            containerWidth: width,\n                            containerHeight: height,\n                            theme,\n                        })\n                    })\n                } else {\n                    // layer(ctx, {})\n                }\n            })\n        }, [\n            canvasEl,\n            outerWidth,\n            outerHeight,\n            margin,\n            pixelRatio,\n            theme,\n            path,\n            graticule,\n            getFillColor,\n            getBorderWidth,\n            getBorderColor,\n            boundFeatures,\n            legends,\n            layers,\n        ])\n\n        const { showTooltipFromEvent, hideTooltip } = useTooltip()\n        const handleMouseMove = useCallback(\n            event => {\n                if (!isInteractive || !Tooltip) return\n\n                const feature = getFeatureFromMouseEvent(\n                    event,\n                    canvasEl.current,\n                    boundFeatures,\n                    projection\n                )\n                if (feature) {\n                    showTooltipFromEvent(<Tooltip feature={feature} />, event)\n                } else {\n                    hideTooltip()\n                }\n                onMouseMove && onMouseMove(feature || null, event)\n            },\n            [\n                showTooltipFromEvent,\n                hideTooltip,\n                isInteractive,\n                Tooltip,\n                canvasEl,\n                boundFeatures,\n                projection,\n            ]\n        )\n        const handleMouseLeave = useCallback(\n            () => isInteractive && hideTooltip(),\n            [isInteractive, hideTooltip]\n        )\n        const handleClick = useCallback(\n            event => {\n                if (!isInteractive || !onClick) return\n\n                const feature = getFeatureFromMouseEvent(\n                    event,\n                    canvasEl.current,\n                    boundFeatures,\n                    projection\n                )\n                if (feature) {\n                    onClick(feature, event)\n                }\n            },\n            [isInteractive, canvasEl, boundFeatures, projection, onClick]\n        )\n\n        return (\n            <canvas\n                ref={canvasEl}\n                width={outerWidth * pixelRatio}\n                height={outerHeight * pixelRatio}\n                style={{\n                    width: outerWidth,\n                    height: outerHeight,\n                    cursor: isInteractive ? 'auto' : 'normal',\n                }}\n                onMouseMove={handleMouseMove}\n                onMouseLeave={handleMouseLeave}\n                onClick={handleClick}\n            />\n        )\n    }\n)\n\nChoroplethCanvas.displayName = 'ChoroplethCanvas'\nChoroplethCanvas.propTypes = ChoroplethCanvasPropTypes\nChoroplethCanvas.defaultProps = ChoroplethCanvasDefaultProps\n\nexport default withContainer(ChoroplethCanvas)\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { ResponsiveWrapper } from '@nivo/core'\nimport ChoroplethCanvas from './ChoroplethCanvas'\n\nconst ResponsiveChoroplethCanvas = props => (\n    <ResponsiveWrapper>\n        {({ width, height }) => <ChoroplethCanvas width={width} height={height} {...props} />}\n    </ResponsiveWrapper>\n)\n\nexport default ResponsiveChoroplethCanvas\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}